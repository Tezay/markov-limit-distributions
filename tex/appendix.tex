\section{Annexes}

\subsection{Scripts et programmes}

\begin{lstlisting}[style=codeblock,caption={Distribution sur une étape puis t étapes (dist\_step et dist\_power)},label={lst:dist_power}]
/**
 * @brief  Effectue une etape de distribution : pi1 = pi0 * M
 *
 * Les vecteurs `pi0` et `pi1` sont de taille `M->n`
 *
 * @param[in]  pi0  Distribution initiale (taille n)
 * @param[in]  M    Matrice de transition n x n (lignes = etats de depart)
 * @param[out] pi1  Distribution resultante (taille n)
 */
void dist_step(const float *pi0, const t_matrix *M, float *pi1) {
    if (!M || !M->a || M->n <= 0 || !pi0 || !pi1) {
        fprintf(stderr, "[matrix][ERR] Parametres invalides dans dist_step\n");
        exit(EXIT_FAILURE);
    }

    int size = M->n;

    // Calcul de pi1 = pi0 * M
    for (int col = 0; col < size; ++col) {
        float sum = 0.0f;
        for (int row = 0; row < size; ++row) {
            sum += pi0[row] * M->a[row][col];
        }
        pi1[col] = sum;
    }
}

  /**
 * @brief  Calcule Pi_t = Pi_0 M^t par iterations successives
 *
 * Utilise `dist_step` de maniere repete pour appliquer `t` transitions.
 * Si `t == 0`, la fonction recopie simplement `pi_0` dans `pi_t`.
 *
 * @param[in]  pi0  Distribution initiale (taille n)
 * @param[in]  M    Matrice de transition n x n
 * @param[in]  t    Nombre d'etapes (t >= 0)
 * @param[out] pit  Distribution apres t etapes (taille n)
 */
void dist_power(const float *pi0, const t_matrix *M, int t, float *pit) {
    if (!M || !M->a || M->n <= 0 || !pi0 || !pit || t < 0) {
        fprintf(stderr, "[matrix][ERR] Parametres invalides dans dist_power\n");
        exit(EXIT_FAILURE);
    }

    int size = M->n;

    // Cas trivial : t == 0 => copie directe
    if (t == 0) {
        for (int index = 0; index < size; ++index) {
            pit[index] = pi0[index];
        }
        return;
    }

    // Allocation de deux vecteurs temporaires pour les etapes
    float *current = (float *)malloc((size_t)size * sizeof(float));
    float *next = (float *)malloc((size_t)size * sizeof(float));
    if (!current || !next) {
        perror("malloc");
        free(current);
        free(next);
        exit(EXIT_FAILURE);
    }

    // Init distribution courante
    for (int index = 0; index < size; ++index) {
        current[index] = pi0[index];
    }

    // Iterations successives pour t etapes
    for (int step = 0; step < t; ++step) {
        dist_step(current, M, next);

        float *tmp = current;
        current = next;
        next = tmp;
    }

    // Copie du resultat final dans pit
    for (int index = 0; index < size; ++index) {
        pit[index] = current[index];
    }

    free(current);
    free(next);
}
\end{lstlisting}

\begin{lstlisting}[style=codeblock,caption={Calcul numérique de la distribution stationnaire sur une classe persistante},label={lst:stationary}]
/**
 * @brief  Calcule la distribution stationnaire d'une matrice de transition
 *
 * @param MC       Matrice de transition de la classe persistante
 * @param eps      Tolerance de convergence
 * @param max_iter Nombre maximal d'iterations
 * @param pi_out   Tableau de sortie pour la distribution stationnaire (taille MC->n)
 *
 * @return 1 si convergence atteinte, 0 sinon
 */
int stationary_distribution(const t_matrix *MC, float eps, int max_iter, float *pi_out) {
    if (!MC || !MC->a || MC->n <= 0 || !pi_out || max_iter <= 0) {
        return 0;
    }
    if (eps < 0.0f) eps = -eps;

    int n = MC->n;
    float *cur = (float *)malloc((size_t)n * sizeof(float));
    float *next = (float *)malloc((size_t)n * sizeof(float));
    if (!cur || !next) {
        free(cur); free(next);
        perror("malloc");
        return 0;
    }

    // Distribution initiale uniforme
    for (int i = 0; i < n; ++i) cur[i] = 1.0f / (float)n;

    int converged = 0;
    for (int it = 0; it < max_iter; ++it) {
        dist_step(cur, MC, next);
        float d = dist_l1(cur, next, n);
        for (int i = 0; i < n; ++i) cur[i] = next[i];
        if (d < eps) { converged = 1; break; }
    }

    for (int i = 0; i < n; ++i) pi_out[i] = cur[i];
    free(cur);
    free(next);
    return converged;
}
\end{lstlisting}

\subsection{Matrice de transition}
\placeholder{Rappeler la matrice 27x27 ou la source du fichier \texttt{input\_data/matrix.txt}.}

\subsection{Figures supplémentaires}
\placeholder{Déposer ici les graphes détaillés (convergences, diagrammes de Hasse, etc.) qui complètent le corps du texte.}
